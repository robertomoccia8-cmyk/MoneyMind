Linea Guida Completa: Potenziamento del Sistema di Classificazione Pattern-Transazioni
Basata sulla struttura del tuo progetto GestioneFinanzePersonali, ecco una guida dettagliata per ottimizzare il matching pattern-descrizione e potenziare la classificazione automatica.

1. ANALISI DELLA STRUTTURA ATTUALE
1.1 Componenti Esistenti
Classes/Models/Transazione.vb: Entità dati transazione

Classes/Services/ClassificatoreTransazioni.vb: Logica di classificazione

Classes/Database/DatabaseManager.vb: Gestione database

Forms/Transazioni/FormGestionePattern.vb: Interfaccia gestione pattern

1.2 Punti di Miglioramento Identificati
Mancanza di una classe Pattern dedicata nei Models

Algoritmi di matching troppo semplici (solo regex base)

Assenza di machine learning o AI per pattern complessi

Nessun sistema di feedback per migliorare i pattern

Mancanza di preprocessing avanzato delle descrizioni

2. POTENZIAMENTO DEL MODELLO DATI
2.1 Creare Classes/Models/Pattern.vb
text
Public Class Pattern
    Public Property ID As Integer
    Public Property Parola As String
    Public Property MacroCategoria As String
    Public Property Categoria As String
    Public Property SottoCategoria As String
    Public Property Necessita As String
    Public Property Frequenza As String
    Public Property Stagionalita As String
    Public Property Fonte As String
    Public Property Peso As Integer ' 1-10, priorità del pattern
    Public Property TipoMatch As String ' EXACT, CONTAINS, REGEX, FUZZY
    Public Property PatternRegex As String ' pattern regex personalizzato
    Public Property Sinonimi As String ' parole alternative separate da virgola
    Public Property EscludiSe As String ' condizioni di esclusione
    Public Property CaseSensitive As Boolean
    Public Property DataCreazione As DateTime
    Public Property UltimoUtilizzo As DateTime
    Public Property ContatoreUtilizzo As Integer
    Public Property Attivo As Boolean
End Class
2.2 Estendere la Tabella Pattern nel Database
sql
ALTER TABLE Pattern ADD COLUMN Peso INTEGER DEFAULT 5;
ALTER TABLE Pattern ADD COLUMN TipoMatch TEXT DEFAULT 'CONTAINS';
ALTER TABLE Pattern ADD COLUMN PatternRegex TEXT;
ALTER TABLE Pattern ADD COLUMN Sinonimi TEXT;
ALTER TABLE Pattern ADD COLUMN EscludiSe TEXT;
ALTER TABLE Pattern ADD COLUMN CaseSensitive BOOLEAN DEFAULT 0;
ALTER TABLE Pattern ADD COLUMN DataCreazione DATETIME DEFAULT CURRENT_TIMESTAMP;
ALTER TABLE Pattern ADD COLUMN UltimoUtilizzo DATETIME;
ALTER TABLE Pattern ADD COLUMN ContatoreUtilizzo INTEGER DEFAULT 0;
ALTER TABLE Pattern ADD COLUMN Attivo BOOLEAN DEFAULT 1;
3. ALGORITMI DI MATCHING AVANZATI
3.1 Creare Classes/Services/AdvancedPatternMatcher.vb
text
Imports System.Text.RegularExpressions

Public Class AdvancedPatternMatcher
    
    Public Shared Function CalculateMatchScore(descrizione As String, pattern As Pattern) As Double
        Dim score As Double = 0.0
        Dim normalizedDesc As String = NormalizeDescription(descrizione)
        
        Select Case pattern.TipoMatch.ToUpper()
            Case "EXACT"
                score = ExactMatch(normalizedDesc, pattern)
            Case "CONTAINS"
                score = ContainsMatch(normalizedDesc, pattern)
            Case "REGEX"
                score = RegexMatch(normalizedDesc, pattern)
            Case "FUZZY"
                score = FuzzyMatch(normalizedDesc, pattern)
            Case "SEMANTIC"
                score = SemanticMatch(normalizedDesc, pattern)
        End Select
        
        ' Applica peso del pattern
        score *= (pattern.Peso / 10.0)
        
        ' Verifica condizioni di esclusione
        If HasExclusionConditions(normalizedDesc, pattern) Then
            score = 0.0
        End If
        
        Return score
    End Function
    
    Private Shared Function ExactMatch(descrizione As String, pattern As Pattern) As Double
        Dim target As String = If(pattern.CaseSensitive, pattern.Parola, pattern.Parola.ToLower())
        Dim source As String = If(pattern.CaseSensitive, descrizione, descrizione.ToLower())
        
        If source = target Then Return 1.0
        
        ' Controlla sinonimi
        If Not String.IsNullOrEmpty(pattern.Sinonimi) Then
            Dim sinonimi() As String = pattern.Sinonimi.Split(","c)
            For Each sinonimo In sinonimi
                If source = sinonimo.Trim().ToLower() Then Return 0.9
            Next
        End If
        
        Return 0.0
    End Function
    
    Private Shared Function ContainsMatch(descrizione As String, pattern As Pattern) As Double
        Dim target As String = If(pattern.CaseSensitive, pattern.Parola, pattern.Parola.ToLower())
        Dim source As String = If(pattern.CaseSensitive, descrizione, descrizione.ToLower())
        
        If source.Contains(target) Then
            ' Score basato sulla percentuale di match
            Return CDbl(target.Length) / CDbl(source.Length)
        End If
        
        ' Controlla sinonimi
        If Not String.IsNullOrEmpty(pattern.Sinonimi) Then
            Dim sinonimi() As String = pattern.Sinonimi.Split(","c)
            For Each sinonimo In sinonimi
                If source.Contains(sinonimo.Trim().ToLower()) Then
                    Return CDbl(sinonimo.Trim().Length) / CDbl(source.Length) * 0.9
                End If
            Next
        End If
        
        Return 0.0
    End Function
    
    Private Shared Function RegexMatch(descrizione As String, pattern As Pattern) As Double
        Try
            Dim regex As New Regex(pattern.PatternRegex, 
                If(pattern.CaseSensitive, RegexOptions.None, RegexOptions.IgnoreCase))
            Dim match As Match = regex.Match(descrizione)
            
            If match.Success Then
                Return CDbl(match.Length) / CDbl(descrizione.Length)
            End If
        Catch ex As Exception
            ' Pattern regex non valido
            Return 0.0
        End Try
        
        Return 0.0
    End Function
    
    Private Shared Function FuzzyMatch(descrizione As String, pattern As Pattern) As Double
        ' Implementa algoritmo Levenshtein Distance
        Dim distance As Integer = LevenshteinDistance(descrizione.ToLower(), pattern.Parola.ToLower())
        Dim maxLength As Integer = Math.Max(descrizione.Length, pattern.Parola.Length)
        
        If maxLength = 0 Then Return 1.0
        
        Dim similarity As Double = 1.0 - (CDbl(distance) / CDbl(maxLength))
        
        ' Soglia minima per considerare un match fuzzy
        If similarity >= 0.8 Then Return similarity
        
        Return 0.0
    End Function
    
    Private Shared Function SemanticMatch(descrizione As String, pattern As Pattern) As Double
        ' Implementazione semplificata di matching semantico
        ' In un'implementazione reale, si userebbe un modello di word embeddings
        
        Dim paroleDescrizione() As String = descrizione.ToLower().Split(" "c)
        Dim parolePattern() As String = pattern.Parola.ToLower().Split(" "c)
        
        Dim matches As Integer = 0
        For Each parolaDesc In paroleDescrizione
            For Each parolaPattern In parolePattern
                If parolaDesc = parolaPattern OrElse 
                   AreSemanticallySimilar(parolaDesc, parolaPattern) Then
                    matches += 1
                    Exit For
                End If
            Next
        Next
        
        Return CDbl(matches) / CDbl(parolePattern.Length)
    End Function
    
    Private Shared Function AreSemanticallySimilar(parola1 As String, parola2 As String) As Boolean
        ' Dizionario semplificato di sinonimi/parole semanticamente simili
        Dim synonymGroups As New Dictionary(Of String, String()) From {
            {"pagamento", {"pago", "versamento", "bonifico", "addebito"}},
            {"acquisto", {"compra", "shopping", "spesa", "acquisti"}},
            {"carburante", {"benzina", "gasolio", "diesel", "metano", "gpl"}},
            {"supermercato", {"market", "conad", "coop", "esselunga", "carrefour"}},
            {"ristorante", {"bar", "pizzeria", "trattoria", "osteria", "pub"}},
            {"medico", {"dottore", "clinica", "ospedale", "ambulatorio"}},
            {"trasporto", {"taxi", "bus", "metro", "treno", "aereo"}}
        }
        
        For Each group In synonymGroups
            If group.Value.Contains(parola1) AndAlso group.Value.Contains(parola2) Then
                Return True
            End If
        Next
        
        Return False
    End Function
    
    Private Shared Function LevenshteinDistance(s1 As String, s2 As String) As Integer
        Dim len1 As Integer = s1.Length
        Dim len2 As Integer = s2.Length
        Dim matrix(len1, len2) As Integer
        
        For i As Integer = 0 To len1
            matrix(i, 0) = i
        Next
        For j As Integer = 0 To len2
            matrix(0, j) = j
        Next
        
        For i As Integer = 1 To len1
            For j As Integer = 1 To len2
                Dim cost As Integer = If(s1(i - 1) = s2(j - 1), 0, 1)
                matrix(i, j) = Math.Min(Math.Min(
                    matrix(i - 1, j) + 1,
                    matrix(i, j - 1) + 1),
                    matrix(i - 1, j - 1) + cost)
            Next
        Next
        
        Return matrix(len1, len2)
    End Function
    
    Private Shared Function HasExclusionConditions(descrizione As String, pattern As Pattern) As Boolean
        If String.IsNullOrEmpty(pattern.EscludiSe) Then Return False
        
        Dim exclusions() As String = pattern.EscludiSe.Split(","c)
        For Each exclusion In exclusions
            If descrizione.ToLower().Contains(exclusion.Trim().ToLower()) Then
                Return True
            End If
        Next
        
        Return False
    End Function
    
    Private Shared Function NormalizeDescription(descrizione As String) As String
        ' Normalizzazione avanzata della descrizione
        Dim result As String = descrizione.Trim().ToLower()
        
        ' Rimuovi caratteri speciali e multipli spazi
        result = Regex.Replace(result, "[^\w\s]", " ")
        result = Regex.Replace(result, "\s+", " ")
        
        ' Rimuovi parole comuni non significative
        Dim stopWords() As String = {"il", "la", "lo", "le", "gli", "di", "da", "a", "in", "con", "su", "per", "tra", "fra", "e", "o", "ma", "se", "che", "del", "della", "dello", "delle", "dei", "degli", "al", "alla", "allo", "alle", "ai", "agli", "dal", "dalla", "dallo", "dalle", "dai", "dagli", "nel", "nella", "nello", "nelle", "nei", "negli", "sul", "sulla", "sullo", "sulle", "sui", "sugli"}
        
        Dim words() As String = result.Split(" "c)
        Dim filteredWords As New List(Of String)
        
        For Each word In words
            If Not stopWords.Contains(word) AndAlso word.Length > 2 Then
                filteredWords.Add(word)
            End If
        Next
        
        Return String.Join(" ", filteredWords)
    End Function
End Class
4. POTENZIAMENTO DEL CLASSIFICATORE
4.1 Aggiornare Classes/Services/ClassificatoreTransazioni.vb
text
Public Class ClassificatoreTransazioni
    
    Public Shared Function ClassificaTutteLeTransazioni() As Integer
        Dim classificate As Integer = 0
        Dim patterns As List(Of Pattern) = CaricaPatternAvanzati()
        
        Using conn As New SQLiteConnection(DatabaseManager.GetConnectionString())
            conn.Open()
            
            ' Carica transazioni da classificare
            Dim transazioni As List(Of Transazione) = CaricaTransazioniDaClassificare(conn)
            
            For Each transazione In transazioni
                Dim bestMatch As PatternMatch = TrovaMigliorMatch(transazione.Descrizione, patterns)
                
                If bestMatch IsNot Nothing AndAlso bestMatch.Score >= 0.6 Then ' Soglia minima
                    AggiornaTransazione(conn, transazione.ID, bestMatch.Pattern)
                    AggiornStatistichePattern(conn, bestMatch.Pattern.ID)
                    classificate += 1
                End If
            Next
        End Using
        
        Return classificate
    End Function
    
    Private Shared Function TrovaMigliorMatch(descrizione As String, patterns As List(Of Pattern)) As PatternMatch
        Dim matches As New List(Of PatternMatch)
        
        For Each pattern In patterns
            If Not pattern.Attivo Then Continue For
            
            Dim score As Double = AdvancedPatternMatcher.CalculateMatchScore(descrizione, pattern)
            If score > 0 Then
                matches.Add(New PatternMatch With {
                    .Pattern = pattern,
                    .Score = score,
                    .Descrizione = descrizione
                })
            End If
        Next
        
        ' Ordina per score decrescente e restituisce il migliore
        If matches.Count > 0 Then
            Return matches.OrderByDescending(Function(m) m.Score).First()
        End If
        
        Return Nothing
    End Function
    
    Private Shared Function CaricaPatternAvanzati() As List(Of Pattern)
        Dim patterns As New List(Of Pattern)
        
        Using conn As New SQLiteConnection(DatabaseManager.GetConnectionString())
            conn.Open()
            Dim sql As String = "SELECT * FROM Pattern WHERE Attivo = 1 ORDER BY Peso DESC, ContatoreUtilizzo DESC"
            
            Using cmd As New SQLiteCommand(sql, conn)
                Using reader As SQLiteDataReader = cmd.ExecuteReader()
                    While reader.Read()
                        patterns.Add(New Pattern With {
                            .ID = reader("ID"),
                            .Parola = reader("Parola").ToString(),
                            .MacroCategoria = reader("MacroCategoria").ToString(),
                            .Categoria = reader("Categoria").ToString(),
                            .SottoCategoria = reader("SottoCategoria").ToString(),
                            .Necessita = reader("Necessita").ToString(),
                            .Frequenza = reader("Frequenza").ToString(),
                            .Stagionalita = reader("Stagionalita").ToString(),
                            .Fonte = If(reader.IsDBNull(reader.GetOrdinal("Fonte")), String.Empty, reader("Fonte").ToString()),
                            .Peso = If(reader.IsDBNull(reader.GetOrdinal("Peso")), 5, reader("Peso")),
                            .TipoMatch = If(reader.IsDBNull(reader.GetOrdinal("TipoMatch")), "CONTAINS", reader("TipoMatch").ToString()),
                            .PatternRegex = If(reader.IsDBNull(reader.GetOrdinal("PatternRegex")), String.Empty, reader("PatternRegex").ToString()),
                            .Sinonimi = If(reader.IsDBNull(reader.GetOrdinal("Sinonimi")), String.Empty, reader("Sinonimi").ToString()),
                            .EscludiSe = If(reader.IsDBNull(reader.GetOrdinal("EscludiSe")), String.Empty, reader("EscludiSe").ToString()),
                            .CaseSensitive = If(reader.IsDBNull(reader.GetOrdinal("CaseSensitive")), False, reader("CaseSensitive")),
                            .ContatoreUtilizzo = If(reader.IsDBNull(reader.GetOrdinal("ContatoreUtilizzo")), 0, reader("ContatoreUtilizzo")),
                            .Attivo = If(reader.IsDBNull(reader.GetOrdinal("Attivo")), True, reader("Attivo"))
                        })
                    End While
                End Using
            End Using
        End Using
        
        Return patterns
    End Function
    
    Private Shared Sub AggiornStatistichePattern(conn As SQLiteConnection, patternId As Integer)
        Dim sql As String = "UPDATE Pattern SET ContatoreUtilizzo = ContatoreUtilizzo + 1, UltimoUtilizzo = ? WHERE ID = ?"
        Using cmd As New SQLiteCommand(sql, conn)
            cmd.Parameters.AddWithValue("@uso", DateTime.Now)
            cmd.Parameters.AddWithValue("@id", patternId)
            cmd.ExecuteNonQuery()
        End Using
    End Sub
End Class

Public Class PatternMatch
    Public Property Pattern As Pattern
    Public Property Score As Double
    Public Property Descrizione As String
End Class
5. SISTEMA DI APPRENDIMENTO E FEEDBACK
5.1 Creare Classes/Services/LearningSystem.vb
text
Public Class LearningSystem
    
    Public Shared Sub RegistraFeedbackUtente(transazioneId As Integer, patternId As Integer, 
                                           feedbackPositivo As Boolean, categoriaCorretta As String)
        Using conn As New SQLiteConnection(DatabaseManager.GetConnectionString())
            conn.Open()
            
            ' Registra il feedback
            Dim sql As String = "INSERT INTO FeedbackPattern (TransazioneID, PatternID, FeedbackPositivo, CategoriaCorretta, DataFeedback) VALUES (?, ?, ?, ?, ?)"
            Using cmd As New SQLiteCommand(sql, conn)
                cmd.Parameters.AddWithValue("@tid", transazioneId)
                cmd.Parameters.AddWithValue("@pid", patternId)
                cmd.Parameters.AddWithValue("@feedback", feedbackPositivo)
                cmd.Parameters.AddWithValue("@categoria", categoriaCorretta)
                cmd.Parameters.AddWithValue("@data", DateTime.Now)
                cmd.ExecuteNonQuery()
            End Using
            
            ' Aggiorna peso del pattern in base al feedback
            If feedbackPositivo Then
                AggiornaUsoPattern(conn, patternId, 1)
            Else
                AggiornaUsoPattern(conn, patternId, -1)
                ' Suggerisci creazione di un nuovo pattern se necessario
                SuggerisciNuovoPattern(conn, transazioneId, categoriaCorretta)
            End If
        End Using
    End Sub
    
    Public Shared Sub AnalizzaECreaNuoviPattern()
        Using conn As New SQLiteConnection(DatabaseManager.GetConnectionString())
            conn.Open()
            
            ' Trova transazioni classificate manualmente dall'utente
            Dim sql As String = "SELECT Descrizione, MacroCategoria, Categoria, COUNT(*) as Occorrenze " &
                               "FROM Transazioni WHERE MacroCategoria IS NOT NULL AND DataModifica > DataInserimento " &
                               "GROUP BY Descrizione, MacroCategoria, Categoria HAVING COUNT(*) >= 3"
            
            Using cmd As New SQLiteCommand(sql, conn)
                Using reader As SQLiteDataReader = cmd.ExecuteReader()
                    While reader.Read()
                        Dim descrizione As String = reader("Descrizione").ToString()
                        Dim macrocat As String = reader("MacroCategoria").ToString()
                        Dim categoria As String = reader("Categoria").ToString()
                        Dim occorrenze As Integer = reader("Occorrenze")
                        
                        ' Estrai pattern automaticamente
                        Dim pattern As String = EstraiPatternDaDescrizione(descrizione)
                        If Not String.IsNullOrEmpty(pattern) Then
                            CreaNuovoPatternAutomatico(conn, pattern, macrocat, categoria, occorrenze)
                        End If
                    End While
                End Using
            End Using
        End Using
    End Sub
    
    Private Shared Function EstraiPatternDaDescrizione(descrizione As String) As String
        ' Algoritmo per estrarre pattern significativi da una descrizione
        Dim words() As String = descrizione.ToLower().Split(" "c)
        
        ' Trova la parola più significativa (non stopword, lunghezza > 3)
        Dim stopWords() As String = {"pagamento", "bonifico", "addebito", "prelievo", "pos", "carta"}
        
        For Each word In words
            If word.Length > 3 AndAlso Not stopWords.Contains(word) Then
                Return word
            End If
        Next
        
        Return String.Empty
    End Function
    
    Private Shared Sub CreaNuovoPatternAutomatico(conn As SQLiteConnection, pattern As String, 
                                                macrocat As String, categoria As String, occorrenze As Integer)
        ' Verifica se il pattern esiste già
        Dim checkSql As String = "SELECT COUNT(*) FROM Pattern WHERE Parola = ?"
        Using checkCmd As New SQLiteCommand(checkSql, conn)
            checkCmd.Parameters.AddWithValue("@pattern", pattern)
            If checkCmd.ExecuteScalar() > 0 Then Return ' Pattern già esistente
        End Using
        
        ' Crea nuovo pattern
        Dim sql As String = "INSERT INTO Pattern (Parola, MacroCategoria, Categoria, Peso, TipoMatch, Fonte, DataCreazione, Attivo) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
        Using cmd As New SQLiteCommand(sql, conn)
            cmd.Parameters.AddWithValue("@parola", pattern)
            cmd.Parameters.AddWithValue("@macro", macrocat)
            cmd.Parameters.AddWithValue("@cat", categoria)
            cmd.Parameters.AddWithValue("@peso", Math.Min(occorrenze, 10)) ' Peso basato su occorrenze
            cmd.Parameters.AddWithValue("@tipo", "CONTAINS")
            cmd.Parameters.AddWithValue("@fonte", "AUTO_LEARNING")
            cmd.Parameters.AddWithValue("@data", DateTime.Now)
            cmd.Parameters.AddWithValue("@attivo", True)
            cmd.ExecuteNonQuery()
        End Using
    End Sub
End Class
6. INTERFACCIA UTENTE MIGLIORATA
6.1 Potenziare Forms/Transazioni/FormGestionePattern.vb
Aggiungi controlli per:

Tipo di Match: ComboBox con opzioni (EXACT, CONTAINS, REGEX, FUZZY, SEMANTIC)

Peso Pattern: NumericUpDown (1-10)

Sinonimi: TextBox per inserire sinonimi separati da virgola

Condizioni di Esclusione: TextBox per parole che escludono il match

Test Pattern: Area per testare il pattern contro descrizioni di esempio

Statistiche Utilizzo: Mostra quante volte è stato usato ogni pattern

text
' Esempio di test pattern in tempo reale
Private Sub TestPattern()
    Dim descrizioneTest As String = txtDescrizioneTest.Text
    Dim pattern As New Pattern With {
        .Parola = txtParola.Text,
        .TipoMatch = cmbTipoMatch.SelectedItem.ToString(),
        .Peso = nudPeso.Value,
        .Sinonimi = txtSinonimi.Text,
        .EscludiSe = txtEscludi.Text,
        .CaseSensitive = chkCaseSensitive.Checked
    }
    
    Dim score As Double = AdvancedPatternMatcher.CalculateMatchScore(descrizioneTest, pattern)
    lblRisultatoTest.Text = $"Score: {score:F2} - Match: {If(score >= 0.6, "SÌ", "NO")}"
End Sub
7. SISTEMA DI MONITORAGGIO E OTTIMIZZAZIONE
7.1 Creare Classes/Services/MonitoringSystem.vb
text
Public Class MonitoringSystem
    
    Public Shared Function GetStatisticheClassificazione() As ClassificationStats
        Dim stats As New ClassificationStats
        
        Using conn As New SQLiteConnection(DatabaseManager.GetConnectionString())
            conn.Open()
            
            ' Transazioni totali
            stats.TotaleTransazioni = ExecuteScalar(conn, "SELECT COUNT(*) FROM Transazioni")
            
            ' Transazioni classificate
            stats.TransazioniClassificate = ExecuteScalar(conn, "SELECT COUNT(*) FROM Transazioni WHERE MacroCategoria IS NOT NULL")
            
            ' Pattern più utilizzati
            stats.PatternPiuUtilizzati = GetTopPatterns(conn)
            
            ' Accuratezza (basata su feedback positivi)
            stats.AccuratezzaPercentuale = GetAccuratezza(conn)
            
            ' Categorie più frequenti
            stats.CategoriePiuFrequenti = GetTopCategorie(conn)
        End Using
        
        Return stats
    End Function
    
    Public Shared Sub OptimizePatterns()
        Using conn As New SQLiteConnection(DatabaseManager.GetConnectionString())
            conn.Open()
            
            ' Disattiva pattern con bassa performance
            Dim sqlDisattiva As String = "UPDATE Pattern SET Attivo = 0 WHERE ContatoreUtilizzo > 50 AND (SELECT COUNT(*) FROM FeedbackPattern WHERE PatternID = Pattern.ID AND FeedbackPositivo = 0) > (SELECT COUNT(*) FROM FeedbackPattern WHERE PatternID = Pattern.ID AND FeedbackPositivo = 1) * 2"
            ExecuteNonQuery(conn, sqlDisattiva)
            
            ' Aumenta peso di pattern performanti
            Dim sqlAumentaPeso As String = "UPDATE Pattern SET Peso = CASE WHEN Peso < 10 THEN Peso + 1 ELSE Peso END WHERE ContatoreUtilizzo > 20 AND (SELECT COUNT(*) FROM FeedbackPattern WHERE PatternID = Pattern.ID AND FeedbackPositivo = 1) > (SELECT COUNT(*) FROM FeedbackPattern WHERE PatternID = Pattern.ID AND FeedbackPositivo = 0) * 3"
            ExecuteNonQuery(conn, sqlAumentaPeso)
        End Using
    End Sub
End Class

Public Class ClassificationStats
    Public Property TotaleTransazioni As Integer
    Public Property TransazioniClassificate As Integer
    Public Property PatternPiuUtilizzati As List(Of PatternStat)
    Public Property AccuratezzaPercentuale As Double
    Public Property CategoriePiuFrequenti As List(Of CategoriaStat)
End Class
8. IMPLEMENTAZIONE STEP-BY-STEP
8.1 Fase 1: Foundation (Settimana 1-2)
Aggiorna struttura database con nuove colonne

Crea classe Pattern.vb nei Models

Implementa AdvancedPatternMatcher.vb

8.2 Fase 2: Core Enhancement (Settimana 3-4)
Aggiorna ClassificatoreTransazioni.vb

Implementa sistema di scoring avanzato

Testa con dati esistenti

8.3 Fase 3: Learning System (Settimana 5-6)
Implementa LearningSystem.vb

Crea tabelle per feedback utente

Implementa interfaccia feedback

8.4 Fase 4: UI e Monitoring (Settimana 7-8)
Potenzia FormGestionePattern.vb

Implementa MonitoringSystem.vb

Crea dashboard statistiche

9. CONFIGURAZIONI RACCOMANDATE
9.1 Soglie di Match Ottimali
EXACT: Score >= 0.95

CONTAINS: Score >= 0.6

REGEX: Score >= 0.7

FUZZY: Score >= 0.8

SEMANTIC: Score >= 0.65

9.2 Pattern di Esempio Avanzati
sql
-- Pattern per supermercati con sinonimi
INSERT INTO Pattern (Parola, TipoMatch, Sinonimi, MacroCategoria, Categoria, Peso) 
VALUES ('supermercato', 'SEMANTIC', 'conad,coop,esselunga,carrefour,iper,market', 'Spese', 'Alimentari', 8);

-- Pattern regex per carta di credito
INSERT INTO Pattern (Parola, TipoMatch, PatternRegex, MacroCategoria, Categoria, Peso) 
VALUES ('carta', 'REGEX', 'carta.*\d{4}', 'Spese', 'Pagamento Elettronico', 7);

-- Pattern con esclusioni
INSERT INTO Pattern (Parola, TipoMatch, EscludiSe, MacroCategoria, Categoria, Peso) 
VALUES ('medico', 'CONTAINS', 'veterinario,animale', 'Spese', 'Salute', 6);
10. METRICHE DI SUCCESSO
Accuratezza di Classificazione: > 85%

Copertura Automatica: > 90% delle transazioni classificate automaticamente

Riduzione Intervento Manuale: > 80%

Tempo di Risposta: < 2 secondi per 1000 transazioni

Feedback Positivo Utenti: > 95%

Con questa implementazione completa, il tuo sistema di classificazione diventerà estremamente preciso, auto-migliorante e user-friendly, raggiungendo performance professionali comparabili a software enterprise.